บทที่ 8: JSX vs. TSX: การเลือกใช้ Syntax สำหรับคอมโพเนนต์ใน React
ในบทนี้ เราจะมาทำความเข้าใจความแตกต่างระหว่างไฟล์ .jsx และ .tsx ซึ่งเป็นสองรูปแบบหลักในการสร้างคอมโพเนนต์ของ React เราจะเปรียบเทียบข้อดี-ข้อเสีย และดูตัวอย่างโค้ดเพื่อให้เห็นภาพชัดเจนว่าเมื่อไหร่ควรเลือกใช้อะไร

1. ทำความรู้จัก JSX (.jsx)
JSX (JavaScript XML) คือ Syntax Extension ของ JavaScript ที่ทำให้เราสามารถเขียนโค้ดที่มีหน้าตาคล้าย HTML ลงไปในไฟล์ JavaScript ได้โดยตรง มันช่วยให้การสร้างและออกแบบ UI (User Interface) ทำได้ง่ายและเป็นธรรมชาติมากขึ้น

ตัวอย่างโค้ด (UserProfile.jsx):

JavaScript

// components/UserProfile.jsx

function UserProfile({ name, age, hobbies }) {
  return (
    <div className="user-profile">
      <h1>ชื่อ: {name}</h1>
      <p>อายุ: {age} ปี</p>
      <h3>งานอดิเรก:</h3>
      <ul>
        {hobbies.map(hobby => (
          <li key={hobby}>{hobby}</li>
        ))}
      </ul>
    </div>
  );
}

export default UserProfile;
การนำไปใช้งาน:

JavaScript

// app/page.js

import UserProfile from "../components/UserProfile";

export default function HomePage() {
  const userData = {
    name: "สมชาย",
    age: 30,
    hobbies: ["อ่านหนังสือ", "ดูหนัง", "ปลูกต้นไม้"]
  };

  return (
    <main>
      <UserProfile 
        name={userData.name} 
        age={userData.age} 
        hobbies={userData.hobbies}
      />
    </main>
  );
}
ข้อดีของ JSX:

เรียนรู้ง่าย: สำหรับคนที่มีพื้นฐาน HTML และ JavaScript มาก่อน จะรู้สึกคุ้นเคยและเริ่มต้นได้เร็ว

ความยืดหยุ่นสูง: เนื่องจากเป็น JavaScript ธรรมดา จึงไม่มีข้อจำกัดเรื่อง Type สามารถส่งข้อมูลอะไรก็ได้เข้าไปใน props

ตั้งค่าโปรเจกต์ง่าย: โปรเจกต์ React ที่เป็น JavaScript ล้วน ไม่ต้องมีการตั้งค่า TypeScript เพิ่มเติม

ข้อเสียของ JSX:

ไม่มี Type Safety: นี่คือข้อเสียที่ใหญ่ที่สุด เราจะไม่รู้เลยว่าส่ง props ผิดประเภทจนกว่าโปรแกรมจะรันแล้วเกิดข้อผิดพลาด (Runtime Error) เช่น

พิมพ์ชื่อ prop ผิด (ages แทนที่จะเป็น age)

ส่งข้อมูลผิดประเภท (age="30" ที่เป็น string แทนที่จะเป็น number)

ลืมส่ง prop ที่จำเป็น

Autocomplete/IntelliSense ทำงานได้ไม่เต็มที่: Editor อาจไม่รู้ว่าคอมโพเนนต์นี้ต้องการ props อะไรบ้าง ทำให้การเขียนโค้ดช้าลงและมีโอกาสผิดพลาดสูง

Refactor โค้ดยาก: การเปลี่ยนชื่อหรือประเภทของ prop ในคอมโพเนนต์หนึ่ง อาจทำให้ส่วนอื่นๆ ที่เรียกใช้พังลงโดยที่เราไม่รู้ตัวล่วงหน้า

2. ก้าวสู่โลกของ Type Safety ด้วย TSX (.tsx)
TSX คือการใช้ JSX Syntax ภายในไฟล์ TypeScript (.ts) พูดง่ายๆ คือมันคือ JSX ที่ถูกเสริมพลังด้วยความสามารถของ TypeScript ทำให้เราสามารถกำหนด "ประเภทข้อมูล" (Type) ให้กับ props และ state ของคอมโพเนนต์ได้

ตัวอย่างโค้ด (UserProfile.tsx):

TypeScript

// components/UserProfile.tsx

// 1. กำหนด "พิมพ์เขียว" หรือ interface สำหรับ props
interface UserProfileProps {
  name: string;
  age: number;
  hobbies: string[];
}

// 2. ระบุว่าฟังก์ชันนี้จะรับ props ตามพิมพ์เขียว UserProfileProps
function UserProfile({ name, age, hobbies }: UserProfileProps) {
  return (
    <div className="user-profile">
      <h1>ชื่อ: {name}</h1>
      <p>อายุ: {age} ปี</p>
      <h3>งานอดิเรก:</h3>
      <ul>
        {hobbies.map(hobby => (
          <li key={hobby}>{hobby}</li>
        ))}
      </ul>
    </div>
  );
}

export default UserProfile;
การนำไปใช้งาน (ที่ผิดพลาดเพื่อให้เห็นภาพ):
เมื่อเราพยายามเรียกใช้ UserProfile โดยส่ง props ผิด Editor จะแสดงข้อผิดพลาด ทันที

TypeScript

// app/page.tsx
import UserProfile from "../components/UserProfile";

export default function HomePage() {
  // ลองส่ง props ผิดประเภท (age เป็น string)
  return (
    <main>
      <UserProfile 
        name="สมหญิง"
        age="สามสิบ" // <-- Editor จะขีดเส้นใต้สีแดงทันที พร้อมแจ้งว่า "Type 'string' is not assignable to type 'number'."
        hobbies={["ชอปปิ้ง", "ทำอาหาร"]}
      />
    </main>
  );
}
ข้อดีของ TSX:

Type Safety สูงสุด: ดักจับข้อผิดพลาดได้ตั้งแต่ตอนเขียนโค้ด (Compile-time Error) ลดบั๊กก่อนที่โปรแกรมจะรันจริงได้อย่างมหาศาล

สุดยอด Autocomplete/IntelliSense: Editor รู้ทันทีว่าคอมโพเนนต์ UserProfile ต้องการ props อะไรบ้าง (name, age, hobbies) และแต่ละตัวต้องเป็นข้อมูลประเภทไหน ทำให้เขียนโค้ดได้เร็วและแม่นยำมาก

โค้ดคือเอกสารในตัว (Self-documenting): เพียงแค่ดู interface UserProfileProps ก็สามารถเข้าใจได้ทันทีว่าต้องใช้งานคอมโพเนนต์นี้อย่างไร

Refactor โค้ดได้อย่างมั่นใจ: หากเราเปลี่ยนชื่อ prop ใน interface ตัว TypeScript จะแจ้งเตือนทุกจุดที่เรียกใช้คอมโพเนนต์นี้ว่ามีการเปลี่ยนแปลง ทำให้แก้โค้ดได้ครบถ้วน

ข้อเสียของ TSX:

มี Learning Curve: ต้องใช้เวลาเรียนรู้พื้นฐานของ TypeScript เพิ่มเติม

โค้ดซับซ้อนขึ้นเล็กน้อย (Boilerplate): ต้องเขียน interface หรือ type เพื่อกำหนดรูปแบบของ props เพิ่มขึ้นมา

ตั้งค่าโปรเจกต์ซับซ้อนกว่า: ต้องมีการตั้งค่าไฟล์ tsconfig.json ในตอนเริ่มต้น

3. ตารางเปรียบเทียบ JSX vs. TSX
คุณสมบัติ	JSX (.jsx)	TSX (.tsx)
การตรวจสอบประเภท (Type Safety)	ไม่มี (ตรวจสอบตอน Runtime)	มี (ตรวจสอบตอนเขียนโค้ด)
การดักจับข้อผิดพลาด	เจอเมื่อโปรแกรมรันแล้วพัง	เจอทันทีใน Editor
Autocomplete/IntelliSense	พอใช้ได้ แต่ไม่สมบูรณ์	ยอดเยี่ยมและแม่นยำ
ความง่ายในการเริ่มต้น	ง่ายมาก	ต้องเรียนรู้ TypeScript เพิ่ม
ความน่าเชื่อถือของโค้ด	ต่ำกว่า อาจมีบั๊กซ่อนอยู่	สูงมาก ลดโอกาสเกิดบั๊ก
การทำงานเป็นทีม	อาจเกิดความผิดพลาดในการสื่อสารเรื่อง props	ดีเยี่ยม ทุกคนเข้าใจตรงกันจาก Type ที่กำหนด

ส่งออกไปยังชีต
4. สรุปและคำแนะนำสำหรับ Junior Developer
สำหรับโปรเจกต์เล็กๆ ที่ทำคนเดียว หรือโปรเจกต์ต้นแบบ (Prototype) ที่ต้องการความรวดเร็ว การใช้ JSX ก็ไม่ใช่เรื่องผิด

อย่างไรก็ตาม สำหรับการทำงานจริง ขอแนะนำอย่างยิ่งให้เลือกใช้ TSX ตั้งแต่วันแรก การลงทุนเวลาเพื่อเรียนรู้ TypeScript ในตอนต้น จะช่วยประหยัดเวลาในการหาและแก้บั๊กในระยะยาวได้อย่างมหาศาล มันทำให้โค้ดของเรามีคุณภาพสูงขึ้น น่าเชื่อถือ และง่ายต่อการดูแลรักษา โดยเฉพาะเมื่อโปรเจกต์มีขนาดใหญ่ขึ้นหรือต้องทำงานร่วมกับนักพัฒนาคนอื่นๆ

การเลือกใช้ TSX ไม่ใช่แค่เทรนด์ แต่เป็นมาตรฐานการทำงานที่ช่วยยกระดับคุณภาพของซอฟต์แวร์และเพิ่มประสิทธิภาพของนักพัฒนาในยุคปัจจุบันครับ








จาก file tsx และ jsx นั้นต้องใช้งานจริง ต้องแปลงเป็น html + java script พื้นฐานทั้งหมด ขั้นตอนการแปลง แต่ละ file เป็นอย่างไร และ tsx ทำให้การใช้งานช้าขึ้นหรือไม่



แสดงวิธีคิด
เป็นคำถามที่ยอดเยี่ยมมากครับพี่เจม และเป็นสิ่งที่ Junior Developer หลายคนสงสัย การเข้าใจเรื่องนี้จะทำให้เห็นภาพรวมของ React และ TypeScript ได้ลึกซึ้งขึ้นมากครับ

ผมจะแบ่งคำตอบเป็น 2 ส่วนนะครับ

ส่วนที่ 1: ขั้นตอนการแปลงไฟล์ .jsx และ .tsx ไปเป็นสิ่งที่เบราว์เซอร์เข้าใจ
ถูกต้องเลยครับ เบราว์เซอร์ (Browser) ไม่สามารถอ่านและทำความเข้าใจโค้ดในไฟล์ .jsx หรือ .tsx ได้โดยตรง สิ่งที่เบราว์เซอร์เข้าใจมีเพียง 3 อย่างคือ: HTML, CSS, และ JavaScript (แบบพื้นฐาน)

ดังนั้น ในโปรเจกต์ React/Next.js จะต้องมีกระบวนการที่เรียกว่า "Build" หรือ "Compilation" ซึ่งทำหน้าที่แปลงโค้ดของเราให้กลายเป็นไฟล์พื้นฐานเหล่านั้น กระบวนการนี้ถูกจัดการโดยเครื่องมือที่เรียกว่า Bundler (เช่น Webpack ที่ Next.js ใช้ หรือ Vite) ร่วมกับ Compiler/Transpiler (เช่น Babel, tsc)

ขั้นตอนการแปลงไฟล์ .jsx
กระบวนการนี้ค่อนข้างตรงไปตรงมาครับ

Input: ไฟล์ UserProfile.jsx ที่มีโค้ดหน้าตาคล้าย HTML อยู่ข้างใน

JavaScript

// สิ่งที่เราเขียน
<div className="user-profile">
  <h1>{name}</h1>
</div>
Transpiler (Babel): โค้ดนี้จะถูกส่งเข้าไปในเครื่องมือที่ชื่อว่า Babel ซึ่งเป็น JavaScript Compiler หน้าที่ของมันคือแปลง JSX Syntax ให้กลายเป็นคำสั่ง JavaScript ที่ React เข้าใจได้

Output: Babel จะแปลงโค้ด JSX ด้านบนให้กลายเป็นฟังก์ชัน React.createElement()

JavaScript

// สิ่งที่ Babel แปลงออกมา (โดยประมาณ)
React.createElement("div", { className: "user-profile" }, 
  React.createElement("h1", null, name)
);
Bundler (Webpack): ไฟล์ JavaScript ที่ถูกแปลงแล้วทั้งหมด จะถูกนำมารวมกันเป็นไฟล์เดียว (หรือหลายไฟล์ที่ถูก optimize แล้ว) พร้อมใช้งาน

สรุป Flow ของ .jsx:
ไฟล์ .jsx → Babel → ไฟล์ .js (ที่ใช้ React.createElement) → Webpack → ไฟล์ bundle.js ที่พร้อมใช้งาน

ขั้นตอนการแปลงไฟล์ .tsx
สำหรับ .tsx จะมีขั้นตอนเพิ่มขึ้นมา 1 ขั้นตอนสำคัญ ซึ่งเกิดขึ้น ก่อน ที่จะไปถึง Babel ครับ

Input: ไฟล์ UserProfile.tsx ที่มีทั้ง Type Annotations และ JSX Syntax

TypeScript

interface UserProfileProps { name: string; }

function UserProfile({ name }: UserProfileProps) {
  return <div className="user-profile">...</div>
}
TypeScript Compiler (tsc): โค้ดนี้จะถูกส่งเข้าไปที่ TypeScript Compiler ก่อนเป็นอันดับแรก ซึ่งมันจะทำ 2 อย่าง:

Type Checking: ตรวจสอบว่าเราใช้ Type ถูกต้องทั้งหมดหรือไม่ ถ้าผิดก็จะแจ้ง Error ทันที

Type Stripping: ลบโค้ดส่วนที่เป็น Type ทั้งหมดทิ้งไป เช่น interface UserProfileProps, : UserProfileProps, : string จะถูกลบหายไปจนหมด!

Intermediate Output: ผลลัพธ์ที่ได้จากขั้นตอนนี้ คือไฟล์ที่มีหน้าตาเหมือนกับไฟล์ .jsx ธรรมดาๆ!

JavaScript

// ผลลัพธ์หลังจาก tsc ทำงาน
function UserProfile({ name }) {
  return <div className="user-profile">...</div>
}
Transpiler (Babel): จากจุดนี้ไป กระบวนการจะ เหมือนกับของ .jsx ทุกประการ คือ Babel จะเข้ามาแปลง JSX ที่เหลืออยู่ให้กลายเป็น React.createElement()

สรุป Flow ของ .tsx:
ไฟล์ .tsx → TypeScript Compiler (ลบ Type ทิ้ง) → โค้ดที่หน้าตาเหมือน .jsx → Babel → ไฟล์ .js → Webpack → ไฟล์ bundle.js

ส่วนที่ 2: TSX ทำให้การใช้งาน (Performance) ช้าขึ้นหรือไม่?
คำถามนี้ต้องแยกตอบตามบริบทครับ

1. สำหรับ "ผู้ใช้งานจริง" (End-User Runtime Performance)
คำตอบคือ: ไม่เลยแม้แต่น้อย, ไม่มีความแตกต่างด้าน Performance เลยครับ

เหตุผล: จากขั้นตอนการแปลงไฟล์ .tsx ในส่วนที่ 1 จะเห็นว่าโค้ดส่วนที่เป็น TypeScript ทั้งหมด (Interfaces, Types) จะถูก "ลบทิ้ง" (Stripped away) ไปในระหว่างกระบวนการ Build

ดังนั้น ไฟล์ JavaScript สุดท้าย (bundle.js) ที่ถูกส่งไปให้เบราว์เซอร์ของผู้ใช้งานนั้น มีหน้าตาและขนาดแทบจะเหมือนกัน 100% ไม่ว่าต้นทางจะมาจากไฟล์ .jsx หรือ .tsx ก็ตาม เบราว์เซอร์ไม่เคยเห็นโค้ด TypeScript เลยแม้แต่บรรทัดเดียว ดังนั้นจึงไม่มีผลกระทบต่อความเร็วในการโหลดหรือการทำงานของเว็บแอปพลิเคชันครับ

2. สำหรับ "นักพัฒนา" (Developer Experience & Build Time)
คำตอบคือ: ทำให้กระบวนการ Build "ช้าลงเล็กน้อย" แต่ทำให้การพัฒนาโดยรวม "เร็วขึ้นมาก"

ส่วนที่ช้าลง:

Build Time: กระบวนการ Build ของ .tsx มีขั้นตอน "Type Checking" เพิ่มขึ้นมา ทำให้เวลาที่ใช้ในการคอมไพล์โค้ดหลังจากที่เรากดเซฟอาจจะช้ากว่า .jsx อยู่เล็กน้อย (ในหลักมิลลิวินาที ถึงวินาที ขึ้นอยู่กับขนาดโปรเจกต์) ซึ่งด้วยคอมพิวเตอร์สมัยใหม่ แทบไม่รู้สึกถึงความแตกต่างนี้ครับ

ส่วนที่เร็วขึ้น (และสำคัญกว่ามาก):

ลดเวลา Debug: เราใช้เวลาในการหาและแก้บั๊กที่เกิดจากข้อมูลผิดประเภทน้อยลงมหาศาล เพราะเจอ Error ตั้งแต่ตอนเขียน

เขียนโค้ดเร็วขึ้น: Autocomplete ที่แม่นยำช่วยให้เราเขียนโค้ดได้เร็วขึ้นมาก

Refactor มั่นใจและเร็วขึ้น: การแก้ไขโค้ดทำได้รวดเร็วโดยไม่ต้องกลัวว่าจะไปกระทบส่วนอื่นโดยไม่รู้ตัว

สรุป: TSX อาจทำให้ "เครื่องจักร" (คอมพิวเตอร์ตอน Build) ทำงานช้าลงนิดหน่อย แต่ช่วยให้ "มนุษย์" (นักพัฒนา) ทำงานได้เร็วขึ้นและมีประสิทธิภาพมากขึ้นมหาศาล ซึ่งเป็นสิ่งที่คุ้มค่ากว่ามากครับ

=================================
สำหรับโครงการขนาดใหญ่ คำตอบคือ ควรเลือกใช้ TSX เสมอครับ

นี่คือสรุปเงื่อนไขและเหตุผลประกอบการตัดสินใจครับ

สรุปเงื่อนไขในการเลือกใช้ TSX สำหรับโครงการใหญ่
ให้เลือกใช้ TSX หากโครงการของคุณเข้าเงื่อนไขข้อใดข้อหนึ่ง (หรือหลายข้อ) ดังต่อไปนี้:

เมื่อทำงานร่วมกันเป็นทีม (ตั้งแต่ 2 คนขึ้นไป)

JSX: ทำให้เกิดความเข้าใจผิดได้ง่าย นักพัฒนาคนอื่นอาจไม่รู้ว่าต้องส่ง props อะไรให้คอมโพเนนต์ของคุณบ้าง หรือส่งข้อมูลผิดประเภทโดยไม่ตั้งใจ

TSX: ทำหน้าที่เป็น "สัญญา" หรือ "เอกสาร" ที่ชัดเจน interface หรือ type จะบังคับให้ทุกคนในทีมใช้คอมโพเนนต์ได้ถูกต้องเสมอ ลดข้อผิดพลาดในการสื่อสาร

เมื่อโครงการต้องมีการดูแลรักษาในระยะยาว (Long-term Maintenance)

JSX: เมื่อเวลาผ่านไป การกลับมาแก้ไขโค้ดเก่าจะมีความเสี่ยงสูง การเปลี่ยนชื่อ props ในไฟล์หนึ่ง อาจทำให้แอปพังในอีกส่วนหนึ่งโดยที่เราไม่รู้ตัวล่วงหน้า

TSX: ทำให้การ Refactor หรือแก้ไขโค้ดทำได้อย่างมั่นใจและปลอดภัย เพราะ TypeScript Compiler จะทำหน้าที่เป็นผู้ตรวจสอบ คอยแจ้งเตือนทุกจุดที่ได้รับผลกระทบจากการเปลี่ยนแปลง

เมื่อโครงการมีความซับซ้อนสูง (High Complexity)

JSX: ยิ่งโค้ดซับซ้อน โอกาสที่จะเกิดบั๊กจากการส่งข้อมูลผิดพลาดก็ยิ่งเพิ่มขึ้นเป็นเงาตามตัว การไล่หาต้นตอของปัญหาจะทำได้ยากและใช้เวลานาน

TSX: ช่วยจัดการความซับซ้อนโดยการกำหนดโครงสร้างข้อมูลที่ชัดเจน ทำให้โค้ดทั้งระบบมีความน่าเชื่อถือสูง และลดบั๊กที่เกิดจากความผิดพลาดง่ายๆ (Silly mistakes)

เมื่อต้องการคุณภาพและความน่าเชื่อถือของซอฟต์แวร์สูงสุด

JSX: บั๊กหลายประเภทสามารถเล็ดลอดไปถึงขั้น Production ได้ เพราะข้อผิดพลาดจะแสดงผลก็ต่อเมื่อโค้ดถูกรันแล้วเท่านั้น

TSX: ดักจับบั๊กได้ตั้งแต่ขั้นตอนการพัฒนา (Compile-time) ทำให้มั่นใจได้ว่าโค้ดที่ส่งออกไปมีคุณภาพสูงและมีโอกาสเกิดปัญหาน้อยกว่ามาก

แล้วมีเงื่อนไขไหนที่ควรใช้ JSX ในโครงการใหญ่หรือไม่?
แทบจะไม่มีครับ ข้อยกเว้นเพียงอย่างเดียวที่อาจจะพอมีเหตุผลคือ:

โครงการเดิมเป็น JavaScript ขนาดใหญ่มาก่อน: หากเป็นโครงการเก่าที่มีโค้ด JavaScript (JSX) อยู่แล้วเป็นแสนๆ บรรทัด การย้ายทั้งหมดเป็น TypeScript (TSX) อาจใช้เวลาและทรัพยากรสูงเกินไป (แต่ถึงอย่างนั้น แนวทางที่แนะนำก็คือค่อยๆ ทยอยเปลี่ยนเป็น TSX ทีละส่วน ไม่ใช่การเขียนโค้ดใหม่เป็น JSX ต่อไป)

บทสรุปเปรียบเทียบ
JSX: เหมือนการสร้างตึกสูงโดยใช้แบบร่างคร่าวๆ อาจจะเริ่มได้เร็ว แต่เมื่อสร้างสูงขึ้นเรื่อยๆ ความเสี่ยงที่จะเกิดปัญหาโครงสร้างก็ยิ่งสูงตาม

TSX: เหมือนการสร้างตึกสูงโดยมีพิมพ์เขียว (Blueprint) ที่ละเอียดและแม่นยำ อาจจะต้องใช้เวลาในการวางแผนและเขียนแบบนานขึ้นในตอนแรก แต่จะทำให้การก่อสร้างราบรื่น มั่นคง และสามารถต่อเติมในอนาคตได้อย่างปลอดภัย

ดังนั้น สำหรับโครงการใหญ่ การลงทุนเรียนรู้และตั้งค่า TypeScript (TSX) ในตอนเริ่มต้น คือการลงทุนเพื่อความสำเร็จและความยั่งยืนของโครงการในระยะยาวครับ