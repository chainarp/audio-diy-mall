บทที่ 2: มาตรฐานการตั้งชื่อ (Naming Convention)
การมีมาตรฐานการตั้งชื่อที่ดีก็เหมือนกับการมี "ภาษา" กลางที่ทุกคนในทีมใช้คุยกัน ทำให้โค้ดอ่านง่าย คาดเดาได้ และลดความสับสนลงได้มหาศาลครับ

1. ภาพรวม Convention ที่นิยมในโลกของ React/Next.js
ก่อนจะลงลึกถึงมาตรฐานของเรา มาดูสิ่งที่คนส่วนใหญ่ในวงการนิยมใช้กันก่อนครับ

Components: ใช้ PascalCase (ตัวแรกของทุกคำเป็นตัวใหญ่)

ตัวอย่าง: ProductCard.jsx, Navbar.jsx

เหตุผลที่นิยม: React กำหนดว่าชื่อ Component ต้องขึ้นต้นด้วยตัวใหญ่ เพื่อให้แยกออกจาก Tag HTML ปกติ (เช่น <ProductCard /> vs <div>)

ไฟล์ที่ไม่ใช่ Component: ใช้ camelCase (ตัวแรกของคำถัดไปเป็นตัวใหญ่)

ตัวอย่าง: lib/utils/formatPrice.js

เหตุผลที่นิยม: เป็นมาตรฐานดั้งเดิมของ JavaScript ทำให้แยกไฟล์ Component ออกจากไฟล์ Logic อื่นๆ ได้ง่ายด้วยสายตา

ตัวแปรและฟังก์ชัน: ใช้ camelCase

ตัวอย่าง: const userStore = ..., function getProducts() { ... }

เหตุผลที่นิยม: เป็นมาตรฐานของ JavaScript ครับ

Custom Hooks: ใช้ use นำหน้าตามด้วย camelCase

ตัวอย่าง: useUser(), useProducts()

เหตุผลที่นิยม: เป็น "กฎ" ของ React ที่บังคับว่า Hook ต้องขึ้นต้นด้วย use เพื่อให้ระบบสามารถตรวจสอบการใช้งานได้ถูกต้อง

Types/Interfaces: ใช้ PascalCase

ตัวอย่าง: type Product = { ... }

เหตุผลที่นิยม: ทำให้แยก "พิมพ์เขียวข้อมูล" (Type) ออกจาก "ข้อมูลจริง" (ตัวแปร) ได้ชัดเจน

2. มาตรฐานสำหรับ Components ของเรา (Model-centric)
เราจะใช้แนวทางที่คุณวางไว้เป็นหลัก คือยึดตาม Model แล้วต่อท้ายด้วย ประเภทของ Component ซึ่งชัดเจนและเหมาะกับโปรเจกต์ของเรามากครับ

รูปแบบ: [Context]<ModelName><ViewType>.jsx

[Context] (อาจจะมีหรือไม่มีก็ได้): บริบทหรือบทบาท เช่น Admin, Vendor

<ModelName>: ชื่อ Model หลัก เช่น Product, Store

<ViewType>: ประเภทการแสดงผลหรือการทำงาน

ประเภทของ Component (<ViewType>) ที่ใช้บ่อย:

List: แสดงข้อมูลหลายรายการ (มักจะใช้ .map() ข้างใน)

Table: แสดงข้อมูลหลายรายการในรูปแบบตาราง

Card: แสดงข้อมูลหนึ่งรายการในรูปแบบการ์ด

Form: ฟอร์มสำหรับกรอกข้อมูล (สร้าง/แก้ไข)

Detail: แสดงรายละเอียดทั้งหมดของข้อมูลหนึ่งรายการ

Item: แสดงข้อมูลหนึ่งรายการย่อยๆ ภายใน List (เช่น CartItem)

Selector: Component สำหรับเลือกข้อมูล (เช่น Dropdown เลือก Store)

การจัดการข้อมูลที่ Join กัน:
เมื่อ Component ต้องแสดงข้อมูลจากหลาย Model ที่ Join กัน ให้ยึด Model หลัก ที่ Component นั้นโฟกัสเป็นหลักในการตั้งชื่อ

Jr. Dev ถาม: "พี่ครับ Component ที่แสดงรายการสินค้าพร้อมกับชื่อร้านค้า ควรจะชื่อ ProductStoreList หรือเปล่าครับ?"

เราตอบ: "ใช้ ProductList ก็พอแล้ว เพราะหน้าที่หลักของมันคือ 'แสดงรายการสินค้า' การที่มีชื่อร้านค้าอยู่ข้างในเป็นแค่รายละเอียดเพิ่มเติม ถ้าเราตั้งชื่อตามทุก Model ที่ Join กัน ชื่อมันจะยาวเกินไปโดยไม่จำเป็น"

3. การจัดการ Component ที่มีหลายรูปแบบ (Variants)
นี่คือประเด็นที่สำคัญมากครับ เมื่อเรามี Component ที่ใช้ Model เดียวกัน แต่ต้องแสดงผลต่างกันในแต่ละหน้า เราจะตั้งชื่อมันอย่างไร?

แนวทาง: ใช้คำคุณศัพท์ (Adjective) หรือคำบอกบริบท (Context) มาขยายชื่อ

ตัวอย่างสถานการณ์: ProductCard
เราต้องการการ์ดสินค้า 3 แบบ:

แบบที่แสดงในหน้าแรกให้ ลูกค้า เห็น (มีรูป, ชื่อ, ราคาขาย, ปุ่ม "เพิ่มลงตะกร้า")

แบบที่แสดงในคลังสินค้าของ ผู้ขาย (มีรูป, ชื่อ, สถานะ, ราคาขาย, ราคาทุน, ปุ่ม "แก้ไข")

แบบที่แสดงใน ตะกร้าสินค้า (มีรูปเล็กๆ, ชื่อ, ราคา, จำนวน, ปุ่ม "ลบ")

วิธีตั้งชื่อเพื่อแยก Variant:

แบบที่ 1 (ลูกค้า): ProductCard.jsx

เหตุผล: เป็นการ์ดสินค้าแบบพื้นฐานที่สุด ให้ใช้ชื่อตั้งต้นได้เลย

แบบที่ 2 (ผู้ขาย): VendorProductCard.jsx หรือ ProductInventoryCard.jsx

เหตุผล: การเติม Vendor หรือ Inventory เข้าไปข้างหน้า บอกชัดเจนว่านี่คือ ProductCard เวอร์ชันสำหรับหน้าของผู้ขาย ซึ่งจะมีข้อมูลและการทำงานไม่เหมือนกับเวอร์ชันปกติ

แบบที่ 3 (ตะกร้าสินค้า): CartItem.jsx

เหตุผล: ในบริบทนี้ มันไม่ได้ทำหน้าที่เป็น "การ์ด" แต่เป็น "ไอเทม" ในตะกร้า ชื่อนี้จึงสื่อความหมายได้ดีที่สุด และบอกเราว่ามันคือการแสดงผล Product ในรูปแบบของตะกร้าสินค้า

สรุปหลักการ: เมื่อมี Variant ให้ถามตัวเองว่า "Component นี้แตกต่างจากเวอร์ชันปกติอย่างไร?" แล้วเอาคำตอบนั้นมาเป็นส่วนหนึ่งของชื่อครับ

4. สรุปมาตรฐานการตั้งชื่อ (Naming Convention) - เวอร์ชันข้อความ
## ประเภท: Routes/Pages ##

รูปแบบ (Pattern): /<role>/<resource>

ตัวอย่าง (Example): app/vendor/products/page.jsx

เหตุผล (Reason): URL สื่อความหมายตามบทบาท (role) และสิ่งที่จัดการ (resource) ทำให้รู้ว่ากำลังทำงานในส่วนไหนของระบบ

## ประเภท: Components ##

รูปแบบ (Pattern): [Context]<ModelName><ViewType>

ตัวอย่าง (Example): ProductCard.jsx, VendorProductTable.jsx

เหตุผล (Reason): ชื่อบอกชัดเจนว่าเกี่ยวกับข้อมูล (Model) อะไร และแสดงผลในรูปแบบ (ViewType) ไหน ทำให้คาดเดาหน้าที่ของ Component ได้ง่าย

## ประเภท: Hooks ##

รูปแบบ (Pattern): use<Something>

ตัวอย่าง (Example): useUser(), useStoreProducts()

เหตุผล (Reason): เป็นกฎของ React และสื่อว่านี่คือ Logic ที่สามารถนำกลับมาใช้ซ้ำได้ (Reusable Logic)

## ประเภท: Functions/Variables ##

รูปแบบ (Pattern): camelCase

ตัวอย่าง (Example): getProductById(), const userStore = ...

เหตุผล (Reason): เป็นมาตรฐานการเขียนโค้ดของ JavaScript

## ประเภท: Types/Interfaces ##

รูปแบบ (Pattern): PascalCase

ตัวอย่าง (Example): type Product = { ... }, interface User { ... }

เหตุผล (Reason): เพื่อแยก "พิมพ์เขียวข้อมูล" (Type) ออกจาก "ข้อมูลที่ใช้งานจริง" (ตัวแปร) ได้อย่างชัดเจน

