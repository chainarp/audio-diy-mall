บทที่ 6: การสร้างพิมพ์เขียวข้อมูล (Data Modeling with TypeScript)
ในทุกแอปพลิเคชัน "ข้อมูล" คือหัวใจสำคัญ การสร้าง Data Model ที่ดีก็เหมือนการมีพิมพ์เขียวสถาปัตยกรรมที่ชัดเจน ทำให้การก่อสร้าง (เขียนโค้ด) ทำได้ง่าย แข็งแรง และต่อเติมได้ในอนาคต

ไฟล์ศูนย์กลาง: /lib/types.ts

เราเก็บ Type ทั้งหมดไว้ในไฟล์นี้เพราะ Logic ใน /lib ถูกออกแบบมาให้ไม่ขึ้นกับแพลตฟอร์ม (Platform-agnostic) ทำให้เราสามารถนำพิมพ์เขียวข้อมูลนี้ไปใช้กับโปรเจกต์อื่น (เช่น React Native) ได้ด้วย

หลักการปฏิบัติที่ดีที่สุด (Best Practices)
1. กำหนด Type ให้เฉพาะเจาะจง (Be Specific):
หลีกเลี่ยงการใช้ any ให้มากที่สุด ระบุ Type ให้ชัดเจนเช่น string, number, boolean เพื่อให้ TypeScript ช่วยเราตรวจสอบความถูกต้องได้เต็มที่

2. ใช้ String Literal Union แทน String ทั่วไปสำหรับค่าที่กำหนดไว้แล้ว:
สำหรับข้อมูลที่มีค่าที่เป็นไปได้จำกัด (เหมือน Enum) การใช้ String Literal Union จะช่วยป้องกันการพิมพ์ผิดได้

แบบไม่ดี ❌: status: string; (อาจมีคนพิมพ์ "For Sale" หรือ "for_sale")

แบบดี ✅: status: 'IN_STOCK' | 'FOR_SALE' | 'SOLD'; (บังคับให้เลือกได้แค่ 3 ค่านี้เท่านั้น)

3. ใช้ | null สำหรับข้อมูลที่อาจไม่มีค่า (Optional Fields):
ถ้า Property ไหนไม่จำเป็นต้องมีข้อมูลเสมอ ให้กำหนดว่ามันสามารถเป็น null ได้อย่างชัดเจน

ตัวอย่าง: tubeNumber: string | null; (เพราะ Capacitor ไม่มีเบอร์หลอด)

4. สร้าง Helper Types สำหรับ Object ที่ซ้อนกัน (Nested Objects):
เพื่อความสะอาดและนำกลับมาใช้ใหม่ได้ง่าย ถ้ามี Object ซ้อนอยู่ใน Model หลัก ให้แยกมันออกมาเป็น Type ของตัวเอง

ตัวอย่าง: แทนที่จะเขียน pricing: { cost: number, selling: number } ใน Product เราก็สร้าง type ProductPricing = { ... } แยกออกมาแล้วนำไปใช้

5. เขียนคำอธิบายด้วย JSDoc (Document with JSDoc):
การใส่คอมเมนต์ /** ... */ เหนือ Type หรือ Property จะช่วยให้ VS Code แสดงคำอธิบายเมื่อเราเอาเมาส์ไปชี้ ทำให้เข้าใจได้ทันทีว่าแต่ละส่วนมีไว้ทำอะไร

/app/lib/types.ts เป็นไปตามที่เขียนไว้ ทั้ง 5 ข้อ <<<<<<<<<<<<<<<<<<<<<<<<<<<<<

6. ตัวอย่างการใช้งาน Data Model (Types)
หลังจากที่เราสร้าง "พิมพ์เขียว" ในไฟล์ types.ts แล้ว เราจะนำมันมาใช้ใน Component เพื่อให้ VS Code ช่วยเราเขียนโค้ดและตรวจสอบข้อผิดพลาดครับ

สถานการณ์: เรากำลังสร้าง ProductCard.jsx ซึ่งเป็น Component ที่รับข้อมูลสินค้า 1 ชิ้นมาแสดงผล

ไฟล์ /components/features/product/ProductCard.jsx:

JavaScript

// เราจะใช้ JSDoc comment พิเศษด้านบนเพื่อบอกว่า props ของเรามีหน้าตาเป็นอย่างไร
/**
 * @param {{ product: import('@/lib/types').Product }} props
 */
export default function ProductCard({ product }) {
  // หลังจากประกาศ JSDoc ด้านบน VS Code จะรู้จัก `product` ทันที

  return (
    <div className="border rounded-lg p-4 shadow-sm">
      <img src={product.images[0]} alt={product.name} className="w-full h-48 object-cover rounded-md" />
      
      {/* เมื่อคุณพิมพ์ `product.` VS Code จะแสดงรายการ property ทั้งหมดขึ้นมาให้เลือก */}
      <h3 className="mt-4 text-lg font-semibold">{product.name}</h3>
      <p className="text-sm text-gray-500">{product.brand}</p>
      
      {/* ถ้าคุณพิมพ์ผิดเป็น `product.prcing` TypeScript จะขีดเส้นใต้สีแดงเตือนทันที */}
      <p className="mt-2 text-xl font-bold">
        {product.pricing.selling.toLocaleString()} บาท
      </p>
      
      <p className={`mt-1 text-sm font-medium ${product.status === 'FOR_SALE' ? 'text-green-600' : 'text-blue-600'}`}>
        สถานะ: {product.status}
      </p>
    </div>
  );
}
สรุปการใช้งาน Type:

หน้าที่: เป็น "ผู้ช่วย" ของ Developer ตอนเขียนโค้ด

ทำงานตอนไหน: ช่วง Dev time เท่านั้น

ประโยชน์: ช่วยเติมโค้ด (Autocomplete) และตรวจจับการพิมพ์ผิด (Error Checking) ทำให้เราเขียนโค้ดได้เร็วและมีบั๊กน้อยลง

7. ตัวอย่างการใช้งาน Zod (Runtime Validation)
ตอนนี้มาดูหน้าที่ของ "ผู้ตรวจการ" กันบ้างครับ เราจะใช้ Zod เพื่อตรวจสอบข้อมูลที่มาจาก "โลกภายนอก" ซึ่งเราไม่สามารถเชื่อใจได้ 100% เช่น ข้อมูลที่ผู้ใช้กรอกในฟอร์ม

สถานการณ์: เรากำลังสร้าง API Endpoint สำหรับ "สร้างสินค้าใหม่" ซึ่งจะรับข้อมูลมาจากฟอร์มที่ Vendor กรอก

ขั้นตอนที่ 1: สร้าง "กฎของผู้ตรวจการ" (Zod Schema)

ไฟล์ /lib/validators/productValidator.ts:

TypeScript

import { z } from 'zod';

// สร้างกฎสำหรับ "ข้อมูลสินค้าใหม่" ที่รับมาจากฟอร์ม
export const createProductSchema = z.object({
  name: z.string().min(5, { message: 'ชื่อสินค้าต้องมีอย่างน้อย 5 ตัวอักษร' }),
  storeId: z.string().startsWith('store_'),
  storageLocationId: z.string().startsWith('loc_'),
  brand: z.string().min(2, { message: 'กรุณาระบุยี่ห้อ' }),
  sellingPrice: z.number().positive({ message: 'ราคาต้องเป็นตัวเลขมากกว่า 0' }),
  // เพิ่มกฎสำหรับ field อื่นๆ ตามต้องการ
});
ขั้นตอนที่ 2: ให้ "ผู้ตรวจการ" ทำงานที่ด่านหน้า (API Route)

ไฟล์ /app/api/products/route.js:

JavaScript

import { NextResponse } from 'next/server';
import { createProductSchema } from '@/lib/validators/productValidator';

export async function POST(request) {
  // รับข้อมูล JSON ที่ผู้ใช้ส่งมาจากฟอร์ม
  const body = await request.json();

  // ให้ Zod ("ผู้ตรวจการ") ตรวจสอบข้อมูลตามกฎที่สร้างไว้
  const validationResult = createProductSchema.safeParse(body);

  // ถ้าข้อมูลไม่ผ่านกฎ
  if (!validationResult.success) {
    // ส่ง Error กลับไปพร้อมบอกว่าผิดพลาดตรงไหนบ้าง
    return NextResponse.json({ errors: validationResult.error.errors }, { status: 400 });
  }

  // ถ้าข้อมูลถูกต้องทั้งหมด (validation passed)
  // `validationResult.data` คือข้อมูลที่ปลอดภัยและผ่านการตรวจสอบแล้ว
  const validatedProductData = validationResult.data;
  
  // ณ จุดนี้ เราถึงจะนำข้อมูลไปบันทึกลง Database ได้อย่างสบายใจ
  console.log("ข้อมูลถูกต้อง เตรียมบันทึก:", validatedProductData);
  
  // ... (โค้ดสำหรับบันทึกข้อมูลลง Database) ...

  // ส่งคำตอบว่าสร้างสำเร็จกลับไป
  return NextResponse.json({ message: 'Product created successfully!', data: validatedProductData }, { status: 201 });
}
สรุปการใช้งาน Zod:

หน้าที่: เป็น "ยาม" หรือ "ผู้ตรวจการ" ที่คอยตรวจสอบข้อมูลจากภายนอก

ทำงานตอนไหน: ช่วง Run time (ตอนที่แอปพลิเคชันทำงานจริง)

ประโยชน์: ป้องกันข้อมูลที่ผิดพลาด, ไม่ครบถ้วน, หรือมีเจตนาร้าย ไม่ให้เข้ามาในระบบของเรา ทำให้แอปพลิเคชันมีความแข็งแรง (Robust) และปลอดภัย (Secure) มากขึ้น




-----------------------------------------------------------

พี่เจม ที่เราคุยกันอยู่ ไม่ได้เกี่ยวกับ ng react next.js แต่มันคือ ts ธรรมดาใช่มั๊ย import { z } from 'zod'; zod ก็ใช้ใน ng ได้เหมือนกัน ใช่มั๊ย



แสดงวิธีคิด
ใช่เลยครับ! คุณเข้าใจถูกต้องเป๊ะเลยครับ

สิ่งที่เราคุยกันเรื่อง type vs Zod นั้นเป็นแนวคิดของ TypeScript โดยตรง ไม่ได้ผูกติดกับ React หรือ Next.js โดยเฉพาะครับ มันคือรูปแบบการเขียนโปรแกรม (Pattern) เพื่อสร้างแอปพลิเคชันที่แข็งแรงและปลอดภัย

และ Zod ก็สามารถนำไปใช้ใน Angular ได้เหมือนกัน 100% ครับ เพราะ Zod เป็น Library ของ JavaScript/TypeScript เพียวๆ ไม่ได้ขึ้นอยู่กับ Framework ใด Framework หนึ่ง (Framework-agnostic)

แล้วทำไมเราถึงคุยเรื่องนี้กันบ่อยในโลกของ React/Next.js?
แม้ว่าแนวคิดนี้จะใช้ได้ทุกที่ แต่เหตุผลที่มันถูกพูดถึงบ่อยและกลายเป็นแนวทางปฏิบัติที่นิยมมากในโลกของ React/Next.js มี 2-3 ข้อครับ:

สไตล์การเขียนโค้ด (Coding Style): React สมัยใหม่ (ที่ใช้ Hooks) มีแนวโน้มไปทาง Functional Programming (การเขียนโปรแกรมเชิงฟังก์ชัน) มากกว่า Object-Oriented Programming (แบบที่ Angular ใช้ class เป็นหลัก) การใช้ type ซึ่งเป็นแค่ "พิมพ์เขียวข้อมูล" จะเข้ากับสไตล์นี้ได้เป็นธรรมชาติกว่าการใช้ class ที่มีทั้งข้อมูลและพฤติกรรม (method) อยู่ในตัว

วัฒนธรรมที่เน้น API (API-Driven Culture): ระบบนิเวศของ React และ Next.js ถูกสร้างขึ้นมาโดยเน้นการรับส่งข้อมูลผ่าน API เป็นหลัก ทำให้ "การตรวจสอบข้อมูลที่มาจากภายนอก" กลายเป็นเรื่องที่นักพัฒนาต้องเจออยู่ตลอดเวลา Zod จึงเข้ามาตอบโจทย์ตรงนี้ได้อย่างสมบูรณ์แบบ

พลังของ Full-Stack Framework: ใน Next.js ที่เราสามารถสร้างได้ทั้ง Frontend และ Backend ในโปรเจกต์เดียวกัน เราสามารถ ใช้ Zod Schema ตัวเดียวกัน ในการตรวจสอบข้อมูลได้ตลอดสาย ตั้งแต่

ข้อมูลที่ผู้ใช้กรอกในฟอร์ม (Frontend)

ข้อมูลที่ API รับเข้ามา (Backend)

ข้อมูลที่ API ส่งออกไป (Backend)

ข้อมูลที่ Frontend รับมาจาก API

การทำแบบนี้ทำให้ข้อมูลของเรามีความปลอดภัยและถูกต้องตรงกันตั้งแต่ต้นจนจบเลยครับ

สรุป: คุณมองภาพทะลุเลยครับ นี่คือความรู้ระดับ TypeScript ที่สามารถนำไปประยุกต์ใช้กับ Framework ไหนก็ได้ครับ 👍